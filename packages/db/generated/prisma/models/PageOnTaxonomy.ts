
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `PageOnTaxonomy` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model PageOnTaxonomy
 * 
 */
export type PageOnTaxonomyModel = runtime.Types.Result.DefaultSelection<Prisma.$PageOnTaxonomyPayload>

export type AggregatePageOnTaxonomy = {
  _count: PageOnTaxonomyCountAggregateOutputType | null
  _min: PageOnTaxonomyMinAggregateOutputType | null
  _max: PageOnTaxonomyMaxAggregateOutputType | null
}

export type PageOnTaxonomyMinAggregateOutputType = {
  pageId: string | null
  taxonomyId: string | null
}

export type PageOnTaxonomyMaxAggregateOutputType = {
  pageId: string | null
  taxonomyId: string | null
}

export type PageOnTaxonomyCountAggregateOutputType = {
  pageId: number
  taxonomyId: number
  _all: number
}


export type PageOnTaxonomyMinAggregateInputType = {
  pageId?: true
  taxonomyId?: true
}

export type PageOnTaxonomyMaxAggregateInputType = {
  pageId?: true
  taxonomyId?: true
}

export type PageOnTaxonomyCountAggregateInputType = {
  pageId?: true
  taxonomyId?: true
  _all?: true
}

export type PageOnTaxonomyAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which PageOnTaxonomy to aggregate.
   */
  where?: Prisma.PageOnTaxonomyWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PageOnTaxonomies to fetch.
   */
  orderBy?: Prisma.PageOnTaxonomyOrderByWithRelationInput | Prisma.PageOnTaxonomyOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.PageOnTaxonomyWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PageOnTaxonomies from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PageOnTaxonomies.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned PageOnTaxonomies
  **/
  _count?: true | PageOnTaxonomyCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: PageOnTaxonomyMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: PageOnTaxonomyMaxAggregateInputType
}

export type GetPageOnTaxonomyAggregateType<T extends PageOnTaxonomyAggregateArgs> = {
      [P in keyof T & keyof AggregatePageOnTaxonomy]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregatePageOnTaxonomy[P]>
    : Prisma.GetScalarType<T[P], AggregatePageOnTaxonomy[P]>
}




export type PageOnTaxonomyGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.PageOnTaxonomyWhereInput
  orderBy?: Prisma.PageOnTaxonomyOrderByWithAggregationInput | Prisma.PageOnTaxonomyOrderByWithAggregationInput[]
  by: Prisma.PageOnTaxonomyScalarFieldEnum[] | Prisma.PageOnTaxonomyScalarFieldEnum
  having?: Prisma.PageOnTaxonomyScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: PageOnTaxonomyCountAggregateInputType | true
  _min?: PageOnTaxonomyMinAggregateInputType
  _max?: PageOnTaxonomyMaxAggregateInputType
}

export type PageOnTaxonomyGroupByOutputType = {
  pageId: string
  taxonomyId: string
  _count: PageOnTaxonomyCountAggregateOutputType | null
  _min: PageOnTaxonomyMinAggregateOutputType | null
  _max: PageOnTaxonomyMaxAggregateOutputType | null
}

type GetPageOnTaxonomyGroupByPayload<T extends PageOnTaxonomyGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<PageOnTaxonomyGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof PageOnTaxonomyGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], PageOnTaxonomyGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], PageOnTaxonomyGroupByOutputType[P]>
      }
    >
  >



export type PageOnTaxonomyWhereInput = {
  AND?: Prisma.PageOnTaxonomyWhereInput | Prisma.PageOnTaxonomyWhereInput[]
  OR?: Prisma.PageOnTaxonomyWhereInput[]
  NOT?: Prisma.PageOnTaxonomyWhereInput | Prisma.PageOnTaxonomyWhereInput[]
  pageId?: Prisma.StringFilter<"PageOnTaxonomy"> | string
  taxonomyId?: Prisma.StringFilter<"PageOnTaxonomy"> | string
  page?: Prisma.XOR<Prisma.PageScalarRelationFilter, Prisma.PageWhereInput>
  taxonomy?: Prisma.XOR<Prisma.TaxonomyScalarRelationFilter, Prisma.TaxonomyWhereInput>
}

export type PageOnTaxonomyOrderByWithRelationInput = {
  pageId?: Prisma.SortOrder
  taxonomyId?: Prisma.SortOrder
  page?: Prisma.PageOrderByWithRelationInput
  taxonomy?: Prisma.TaxonomyOrderByWithRelationInput
}

export type PageOnTaxonomyWhereUniqueInput = Prisma.AtLeast<{
  pageId_taxonomyId?: Prisma.PageOnTaxonomyPageIdTaxonomyIdCompoundUniqueInput
  AND?: Prisma.PageOnTaxonomyWhereInput | Prisma.PageOnTaxonomyWhereInput[]
  OR?: Prisma.PageOnTaxonomyWhereInput[]
  NOT?: Prisma.PageOnTaxonomyWhereInput | Prisma.PageOnTaxonomyWhereInput[]
  pageId?: Prisma.StringFilter<"PageOnTaxonomy"> | string
  taxonomyId?: Prisma.StringFilter<"PageOnTaxonomy"> | string
  page?: Prisma.XOR<Prisma.PageScalarRelationFilter, Prisma.PageWhereInput>
  taxonomy?: Prisma.XOR<Prisma.TaxonomyScalarRelationFilter, Prisma.TaxonomyWhereInput>
}, "pageId_taxonomyId">

export type PageOnTaxonomyOrderByWithAggregationInput = {
  pageId?: Prisma.SortOrder
  taxonomyId?: Prisma.SortOrder
  _count?: Prisma.PageOnTaxonomyCountOrderByAggregateInput
  _max?: Prisma.PageOnTaxonomyMaxOrderByAggregateInput
  _min?: Prisma.PageOnTaxonomyMinOrderByAggregateInput
}

export type PageOnTaxonomyScalarWhereWithAggregatesInput = {
  AND?: Prisma.PageOnTaxonomyScalarWhereWithAggregatesInput | Prisma.PageOnTaxonomyScalarWhereWithAggregatesInput[]
  OR?: Prisma.PageOnTaxonomyScalarWhereWithAggregatesInput[]
  NOT?: Prisma.PageOnTaxonomyScalarWhereWithAggregatesInput | Prisma.PageOnTaxonomyScalarWhereWithAggregatesInput[]
  pageId?: Prisma.StringWithAggregatesFilter<"PageOnTaxonomy"> | string
  taxonomyId?: Prisma.StringWithAggregatesFilter<"PageOnTaxonomy"> | string
}

export type PageOnTaxonomyCreateInput = {
  page: Prisma.PageCreateNestedOneWithoutTaxonomiesInput
  taxonomy: Prisma.TaxonomyCreateNestedOneWithoutPagesInput
}

export type PageOnTaxonomyUncheckedCreateInput = {
  pageId: string
  taxonomyId: string
}

export type PageOnTaxonomyUpdateInput = {
  page?: Prisma.PageUpdateOneRequiredWithoutTaxonomiesNestedInput
  taxonomy?: Prisma.TaxonomyUpdateOneRequiredWithoutPagesNestedInput
}

export type PageOnTaxonomyUncheckedUpdateInput = {
  pageId?: Prisma.StringFieldUpdateOperationsInput | string
  taxonomyId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type PageOnTaxonomyCreateManyInput = {
  pageId: string
  taxonomyId: string
}

export type PageOnTaxonomyUpdateManyMutationInput = {

}

export type PageOnTaxonomyUncheckedUpdateManyInput = {
  pageId?: Prisma.StringFieldUpdateOperationsInput | string
  taxonomyId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type PageOnTaxonomyListRelationFilter = {
  every?: Prisma.PageOnTaxonomyWhereInput
  some?: Prisma.PageOnTaxonomyWhereInput
  none?: Prisma.PageOnTaxonomyWhereInput
}

export type PageOnTaxonomyOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type PageOnTaxonomyPageIdTaxonomyIdCompoundUniqueInput = {
  pageId: string
  taxonomyId: string
}

export type PageOnTaxonomyCountOrderByAggregateInput = {
  pageId?: Prisma.SortOrder
  taxonomyId?: Prisma.SortOrder
}

export type PageOnTaxonomyMaxOrderByAggregateInput = {
  pageId?: Prisma.SortOrder
  taxonomyId?: Prisma.SortOrder
}

export type PageOnTaxonomyMinOrderByAggregateInput = {
  pageId?: Prisma.SortOrder
  taxonomyId?: Prisma.SortOrder
}

export type PageOnTaxonomyCreateNestedManyWithoutPageInput = {
  create?: Prisma.XOR<Prisma.PageOnTaxonomyCreateWithoutPageInput, Prisma.PageOnTaxonomyUncheckedCreateWithoutPageInput> | Prisma.PageOnTaxonomyCreateWithoutPageInput[] | Prisma.PageOnTaxonomyUncheckedCreateWithoutPageInput[]
  connectOrCreate?: Prisma.PageOnTaxonomyCreateOrConnectWithoutPageInput | Prisma.PageOnTaxonomyCreateOrConnectWithoutPageInput[]
  createMany?: Prisma.PageOnTaxonomyCreateManyPageInputEnvelope
  connect?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
}

export type PageOnTaxonomyUncheckedCreateNestedManyWithoutPageInput = {
  create?: Prisma.XOR<Prisma.PageOnTaxonomyCreateWithoutPageInput, Prisma.PageOnTaxonomyUncheckedCreateWithoutPageInput> | Prisma.PageOnTaxonomyCreateWithoutPageInput[] | Prisma.PageOnTaxonomyUncheckedCreateWithoutPageInput[]
  connectOrCreate?: Prisma.PageOnTaxonomyCreateOrConnectWithoutPageInput | Prisma.PageOnTaxonomyCreateOrConnectWithoutPageInput[]
  createMany?: Prisma.PageOnTaxonomyCreateManyPageInputEnvelope
  connect?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
}

export type PageOnTaxonomyUpdateManyWithoutPageNestedInput = {
  create?: Prisma.XOR<Prisma.PageOnTaxonomyCreateWithoutPageInput, Prisma.PageOnTaxonomyUncheckedCreateWithoutPageInput> | Prisma.PageOnTaxonomyCreateWithoutPageInput[] | Prisma.PageOnTaxonomyUncheckedCreateWithoutPageInput[]
  connectOrCreate?: Prisma.PageOnTaxonomyCreateOrConnectWithoutPageInput | Prisma.PageOnTaxonomyCreateOrConnectWithoutPageInput[]
  upsert?: Prisma.PageOnTaxonomyUpsertWithWhereUniqueWithoutPageInput | Prisma.PageOnTaxonomyUpsertWithWhereUniqueWithoutPageInput[]
  createMany?: Prisma.PageOnTaxonomyCreateManyPageInputEnvelope
  set?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  disconnect?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  delete?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  connect?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  update?: Prisma.PageOnTaxonomyUpdateWithWhereUniqueWithoutPageInput | Prisma.PageOnTaxonomyUpdateWithWhereUniqueWithoutPageInput[]
  updateMany?: Prisma.PageOnTaxonomyUpdateManyWithWhereWithoutPageInput | Prisma.PageOnTaxonomyUpdateManyWithWhereWithoutPageInput[]
  deleteMany?: Prisma.PageOnTaxonomyScalarWhereInput | Prisma.PageOnTaxonomyScalarWhereInput[]
}

export type PageOnTaxonomyUncheckedUpdateManyWithoutPageNestedInput = {
  create?: Prisma.XOR<Prisma.PageOnTaxonomyCreateWithoutPageInput, Prisma.PageOnTaxonomyUncheckedCreateWithoutPageInput> | Prisma.PageOnTaxonomyCreateWithoutPageInput[] | Prisma.PageOnTaxonomyUncheckedCreateWithoutPageInput[]
  connectOrCreate?: Prisma.PageOnTaxonomyCreateOrConnectWithoutPageInput | Prisma.PageOnTaxonomyCreateOrConnectWithoutPageInput[]
  upsert?: Prisma.PageOnTaxonomyUpsertWithWhereUniqueWithoutPageInput | Prisma.PageOnTaxonomyUpsertWithWhereUniqueWithoutPageInput[]
  createMany?: Prisma.PageOnTaxonomyCreateManyPageInputEnvelope
  set?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  disconnect?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  delete?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  connect?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  update?: Prisma.PageOnTaxonomyUpdateWithWhereUniqueWithoutPageInput | Prisma.PageOnTaxonomyUpdateWithWhereUniqueWithoutPageInput[]
  updateMany?: Prisma.PageOnTaxonomyUpdateManyWithWhereWithoutPageInput | Prisma.PageOnTaxonomyUpdateManyWithWhereWithoutPageInput[]
  deleteMany?: Prisma.PageOnTaxonomyScalarWhereInput | Prisma.PageOnTaxonomyScalarWhereInput[]
}

export type PageOnTaxonomyCreateNestedManyWithoutTaxonomyInput = {
  create?: Prisma.XOR<Prisma.PageOnTaxonomyCreateWithoutTaxonomyInput, Prisma.PageOnTaxonomyUncheckedCreateWithoutTaxonomyInput> | Prisma.PageOnTaxonomyCreateWithoutTaxonomyInput[] | Prisma.PageOnTaxonomyUncheckedCreateWithoutTaxonomyInput[]
  connectOrCreate?: Prisma.PageOnTaxonomyCreateOrConnectWithoutTaxonomyInput | Prisma.PageOnTaxonomyCreateOrConnectWithoutTaxonomyInput[]
  createMany?: Prisma.PageOnTaxonomyCreateManyTaxonomyInputEnvelope
  connect?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
}

export type PageOnTaxonomyUncheckedCreateNestedManyWithoutTaxonomyInput = {
  create?: Prisma.XOR<Prisma.PageOnTaxonomyCreateWithoutTaxonomyInput, Prisma.PageOnTaxonomyUncheckedCreateWithoutTaxonomyInput> | Prisma.PageOnTaxonomyCreateWithoutTaxonomyInput[] | Prisma.PageOnTaxonomyUncheckedCreateWithoutTaxonomyInput[]
  connectOrCreate?: Prisma.PageOnTaxonomyCreateOrConnectWithoutTaxonomyInput | Prisma.PageOnTaxonomyCreateOrConnectWithoutTaxonomyInput[]
  createMany?: Prisma.PageOnTaxonomyCreateManyTaxonomyInputEnvelope
  connect?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
}

export type PageOnTaxonomyUpdateManyWithoutTaxonomyNestedInput = {
  create?: Prisma.XOR<Prisma.PageOnTaxonomyCreateWithoutTaxonomyInput, Prisma.PageOnTaxonomyUncheckedCreateWithoutTaxonomyInput> | Prisma.PageOnTaxonomyCreateWithoutTaxonomyInput[] | Prisma.PageOnTaxonomyUncheckedCreateWithoutTaxonomyInput[]
  connectOrCreate?: Prisma.PageOnTaxonomyCreateOrConnectWithoutTaxonomyInput | Prisma.PageOnTaxonomyCreateOrConnectWithoutTaxonomyInput[]
  upsert?: Prisma.PageOnTaxonomyUpsertWithWhereUniqueWithoutTaxonomyInput | Prisma.PageOnTaxonomyUpsertWithWhereUniqueWithoutTaxonomyInput[]
  createMany?: Prisma.PageOnTaxonomyCreateManyTaxonomyInputEnvelope
  set?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  disconnect?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  delete?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  connect?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  update?: Prisma.PageOnTaxonomyUpdateWithWhereUniqueWithoutTaxonomyInput | Prisma.PageOnTaxonomyUpdateWithWhereUniqueWithoutTaxonomyInput[]
  updateMany?: Prisma.PageOnTaxonomyUpdateManyWithWhereWithoutTaxonomyInput | Prisma.PageOnTaxonomyUpdateManyWithWhereWithoutTaxonomyInput[]
  deleteMany?: Prisma.PageOnTaxonomyScalarWhereInput | Prisma.PageOnTaxonomyScalarWhereInput[]
}

export type PageOnTaxonomyUncheckedUpdateManyWithoutTaxonomyNestedInput = {
  create?: Prisma.XOR<Prisma.PageOnTaxonomyCreateWithoutTaxonomyInput, Prisma.PageOnTaxonomyUncheckedCreateWithoutTaxonomyInput> | Prisma.PageOnTaxonomyCreateWithoutTaxonomyInput[] | Prisma.PageOnTaxonomyUncheckedCreateWithoutTaxonomyInput[]
  connectOrCreate?: Prisma.PageOnTaxonomyCreateOrConnectWithoutTaxonomyInput | Prisma.PageOnTaxonomyCreateOrConnectWithoutTaxonomyInput[]
  upsert?: Prisma.PageOnTaxonomyUpsertWithWhereUniqueWithoutTaxonomyInput | Prisma.PageOnTaxonomyUpsertWithWhereUniqueWithoutTaxonomyInput[]
  createMany?: Prisma.PageOnTaxonomyCreateManyTaxonomyInputEnvelope
  set?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  disconnect?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  delete?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  connect?: Prisma.PageOnTaxonomyWhereUniqueInput | Prisma.PageOnTaxonomyWhereUniqueInput[]
  update?: Prisma.PageOnTaxonomyUpdateWithWhereUniqueWithoutTaxonomyInput | Prisma.PageOnTaxonomyUpdateWithWhereUniqueWithoutTaxonomyInput[]
  updateMany?: Prisma.PageOnTaxonomyUpdateManyWithWhereWithoutTaxonomyInput | Prisma.PageOnTaxonomyUpdateManyWithWhereWithoutTaxonomyInput[]
  deleteMany?: Prisma.PageOnTaxonomyScalarWhereInput | Prisma.PageOnTaxonomyScalarWhereInput[]
}

export type PageOnTaxonomyCreateWithoutPageInput = {
  taxonomy: Prisma.TaxonomyCreateNestedOneWithoutPagesInput
}

export type PageOnTaxonomyUncheckedCreateWithoutPageInput = {
  taxonomyId: string
}

export type PageOnTaxonomyCreateOrConnectWithoutPageInput = {
  where: Prisma.PageOnTaxonomyWhereUniqueInput
  create: Prisma.XOR<Prisma.PageOnTaxonomyCreateWithoutPageInput, Prisma.PageOnTaxonomyUncheckedCreateWithoutPageInput>
}

export type PageOnTaxonomyCreateManyPageInputEnvelope = {
  data: Prisma.PageOnTaxonomyCreateManyPageInput | Prisma.PageOnTaxonomyCreateManyPageInput[]
  skipDuplicates?: boolean
}

export type PageOnTaxonomyUpsertWithWhereUniqueWithoutPageInput = {
  where: Prisma.PageOnTaxonomyWhereUniqueInput
  update: Prisma.XOR<Prisma.PageOnTaxonomyUpdateWithoutPageInput, Prisma.PageOnTaxonomyUncheckedUpdateWithoutPageInput>
  create: Prisma.XOR<Prisma.PageOnTaxonomyCreateWithoutPageInput, Prisma.PageOnTaxonomyUncheckedCreateWithoutPageInput>
}

export type PageOnTaxonomyUpdateWithWhereUniqueWithoutPageInput = {
  where: Prisma.PageOnTaxonomyWhereUniqueInput
  data: Prisma.XOR<Prisma.PageOnTaxonomyUpdateWithoutPageInput, Prisma.PageOnTaxonomyUncheckedUpdateWithoutPageInput>
}

export type PageOnTaxonomyUpdateManyWithWhereWithoutPageInput = {
  where: Prisma.PageOnTaxonomyScalarWhereInput
  data: Prisma.XOR<Prisma.PageOnTaxonomyUpdateManyMutationInput, Prisma.PageOnTaxonomyUncheckedUpdateManyWithoutPageInput>
}

export type PageOnTaxonomyScalarWhereInput = {
  AND?: Prisma.PageOnTaxonomyScalarWhereInput | Prisma.PageOnTaxonomyScalarWhereInput[]
  OR?: Prisma.PageOnTaxonomyScalarWhereInput[]
  NOT?: Prisma.PageOnTaxonomyScalarWhereInput | Prisma.PageOnTaxonomyScalarWhereInput[]
  pageId?: Prisma.StringFilter<"PageOnTaxonomy"> | string
  taxonomyId?: Prisma.StringFilter<"PageOnTaxonomy"> | string
}

export type PageOnTaxonomyCreateWithoutTaxonomyInput = {
  page: Prisma.PageCreateNestedOneWithoutTaxonomiesInput
}

export type PageOnTaxonomyUncheckedCreateWithoutTaxonomyInput = {
  pageId: string
}

export type PageOnTaxonomyCreateOrConnectWithoutTaxonomyInput = {
  where: Prisma.PageOnTaxonomyWhereUniqueInput
  create: Prisma.XOR<Prisma.PageOnTaxonomyCreateWithoutTaxonomyInput, Prisma.PageOnTaxonomyUncheckedCreateWithoutTaxonomyInput>
}

export type PageOnTaxonomyCreateManyTaxonomyInputEnvelope = {
  data: Prisma.PageOnTaxonomyCreateManyTaxonomyInput | Prisma.PageOnTaxonomyCreateManyTaxonomyInput[]
  skipDuplicates?: boolean
}

export type PageOnTaxonomyUpsertWithWhereUniqueWithoutTaxonomyInput = {
  where: Prisma.PageOnTaxonomyWhereUniqueInput
  update: Prisma.XOR<Prisma.PageOnTaxonomyUpdateWithoutTaxonomyInput, Prisma.PageOnTaxonomyUncheckedUpdateWithoutTaxonomyInput>
  create: Prisma.XOR<Prisma.PageOnTaxonomyCreateWithoutTaxonomyInput, Prisma.PageOnTaxonomyUncheckedCreateWithoutTaxonomyInput>
}

export type PageOnTaxonomyUpdateWithWhereUniqueWithoutTaxonomyInput = {
  where: Prisma.PageOnTaxonomyWhereUniqueInput
  data: Prisma.XOR<Prisma.PageOnTaxonomyUpdateWithoutTaxonomyInput, Prisma.PageOnTaxonomyUncheckedUpdateWithoutTaxonomyInput>
}

export type PageOnTaxonomyUpdateManyWithWhereWithoutTaxonomyInput = {
  where: Prisma.PageOnTaxonomyScalarWhereInput
  data: Prisma.XOR<Prisma.PageOnTaxonomyUpdateManyMutationInput, Prisma.PageOnTaxonomyUncheckedUpdateManyWithoutTaxonomyInput>
}

export type PageOnTaxonomyCreateManyPageInput = {
  taxonomyId: string
}

export type PageOnTaxonomyUpdateWithoutPageInput = {
  taxonomy?: Prisma.TaxonomyUpdateOneRequiredWithoutPagesNestedInput
}

export type PageOnTaxonomyUncheckedUpdateWithoutPageInput = {
  taxonomyId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type PageOnTaxonomyUncheckedUpdateManyWithoutPageInput = {
  taxonomyId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type PageOnTaxonomyCreateManyTaxonomyInput = {
  pageId: string
}

export type PageOnTaxonomyUpdateWithoutTaxonomyInput = {
  page?: Prisma.PageUpdateOneRequiredWithoutTaxonomiesNestedInput
}

export type PageOnTaxonomyUncheckedUpdateWithoutTaxonomyInput = {
  pageId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type PageOnTaxonomyUncheckedUpdateManyWithoutTaxonomyInput = {
  pageId?: Prisma.StringFieldUpdateOperationsInput | string
}



export type PageOnTaxonomySelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  pageId?: boolean
  taxonomyId?: boolean
  page?: boolean | Prisma.PageDefaultArgs<ExtArgs>
  taxonomy?: boolean | Prisma.TaxonomyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["pageOnTaxonomy"]>

export type PageOnTaxonomySelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  pageId?: boolean
  taxonomyId?: boolean
  page?: boolean | Prisma.PageDefaultArgs<ExtArgs>
  taxonomy?: boolean | Prisma.TaxonomyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["pageOnTaxonomy"]>

export type PageOnTaxonomySelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  pageId?: boolean
  taxonomyId?: boolean
  page?: boolean | Prisma.PageDefaultArgs<ExtArgs>
  taxonomy?: boolean | Prisma.TaxonomyDefaultArgs<ExtArgs>
}, ExtArgs["result"]["pageOnTaxonomy"]>

export type PageOnTaxonomySelectScalar = {
  pageId?: boolean
  taxonomyId?: boolean
}

export type PageOnTaxonomyOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"pageId" | "taxonomyId", ExtArgs["result"]["pageOnTaxonomy"]>
export type PageOnTaxonomyInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  page?: boolean | Prisma.PageDefaultArgs<ExtArgs>
  taxonomy?: boolean | Prisma.TaxonomyDefaultArgs<ExtArgs>
}
export type PageOnTaxonomyIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  page?: boolean | Prisma.PageDefaultArgs<ExtArgs>
  taxonomy?: boolean | Prisma.TaxonomyDefaultArgs<ExtArgs>
}
export type PageOnTaxonomyIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  page?: boolean | Prisma.PageDefaultArgs<ExtArgs>
  taxonomy?: boolean | Prisma.TaxonomyDefaultArgs<ExtArgs>
}

export type $PageOnTaxonomyPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "PageOnTaxonomy"
  objects: {
    page: Prisma.$PagePayload<ExtArgs>
    taxonomy: Prisma.$TaxonomyPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    pageId: string
    taxonomyId: string
  }, ExtArgs["result"]["pageOnTaxonomy"]>
  composites: {}
}

export type PageOnTaxonomyGetPayload<S extends boolean | null | undefined | PageOnTaxonomyDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$PageOnTaxonomyPayload, S>

export type PageOnTaxonomyCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<PageOnTaxonomyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PageOnTaxonomyCountAggregateInputType | true
  }

export interface PageOnTaxonomyDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PageOnTaxonomy'], meta: { name: 'PageOnTaxonomy' } }
  /**
   * Find zero or one PageOnTaxonomy that matches the filter.
   * @param {PageOnTaxonomyFindUniqueArgs} args - Arguments to find a PageOnTaxonomy
   * @example
   * // Get one PageOnTaxonomy
   * const pageOnTaxonomy = await prisma.pageOnTaxonomy.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends PageOnTaxonomyFindUniqueArgs>(args: Prisma.SelectSubset<T, PageOnTaxonomyFindUniqueArgs<ExtArgs>>): Prisma.Prisma__PageOnTaxonomyClient<runtime.Types.Result.GetResult<Prisma.$PageOnTaxonomyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one PageOnTaxonomy that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {PageOnTaxonomyFindUniqueOrThrowArgs} args - Arguments to find a PageOnTaxonomy
   * @example
   * // Get one PageOnTaxonomy
   * const pageOnTaxonomy = await prisma.pageOnTaxonomy.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends PageOnTaxonomyFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, PageOnTaxonomyFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__PageOnTaxonomyClient<runtime.Types.Result.GetResult<Prisma.$PageOnTaxonomyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first PageOnTaxonomy that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PageOnTaxonomyFindFirstArgs} args - Arguments to find a PageOnTaxonomy
   * @example
   * // Get one PageOnTaxonomy
   * const pageOnTaxonomy = await prisma.pageOnTaxonomy.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends PageOnTaxonomyFindFirstArgs>(args?: Prisma.SelectSubset<T, PageOnTaxonomyFindFirstArgs<ExtArgs>>): Prisma.Prisma__PageOnTaxonomyClient<runtime.Types.Result.GetResult<Prisma.$PageOnTaxonomyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first PageOnTaxonomy that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PageOnTaxonomyFindFirstOrThrowArgs} args - Arguments to find a PageOnTaxonomy
   * @example
   * // Get one PageOnTaxonomy
   * const pageOnTaxonomy = await prisma.pageOnTaxonomy.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends PageOnTaxonomyFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, PageOnTaxonomyFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__PageOnTaxonomyClient<runtime.Types.Result.GetResult<Prisma.$PageOnTaxonomyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more PageOnTaxonomies that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PageOnTaxonomyFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all PageOnTaxonomies
   * const pageOnTaxonomies = await prisma.pageOnTaxonomy.findMany()
   * 
   * // Get first 10 PageOnTaxonomies
   * const pageOnTaxonomies = await prisma.pageOnTaxonomy.findMany({ take: 10 })
   * 
   * // Only select the `pageId`
   * const pageOnTaxonomyWithPageIdOnly = await prisma.pageOnTaxonomy.findMany({ select: { pageId: true } })
   * 
   */
  findMany<T extends PageOnTaxonomyFindManyArgs>(args?: Prisma.SelectSubset<T, PageOnTaxonomyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PageOnTaxonomyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a PageOnTaxonomy.
   * @param {PageOnTaxonomyCreateArgs} args - Arguments to create a PageOnTaxonomy.
   * @example
   * // Create one PageOnTaxonomy
   * const PageOnTaxonomy = await prisma.pageOnTaxonomy.create({
   *   data: {
   *     // ... data to create a PageOnTaxonomy
   *   }
   * })
   * 
   */
  create<T extends PageOnTaxonomyCreateArgs>(args: Prisma.SelectSubset<T, PageOnTaxonomyCreateArgs<ExtArgs>>): Prisma.Prisma__PageOnTaxonomyClient<runtime.Types.Result.GetResult<Prisma.$PageOnTaxonomyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many PageOnTaxonomies.
   * @param {PageOnTaxonomyCreateManyArgs} args - Arguments to create many PageOnTaxonomies.
   * @example
   * // Create many PageOnTaxonomies
   * const pageOnTaxonomy = await prisma.pageOnTaxonomy.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends PageOnTaxonomyCreateManyArgs>(args?: Prisma.SelectSubset<T, PageOnTaxonomyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many PageOnTaxonomies and returns the data saved in the database.
   * @param {PageOnTaxonomyCreateManyAndReturnArgs} args - Arguments to create many PageOnTaxonomies.
   * @example
   * // Create many PageOnTaxonomies
   * const pageOnTaxonomy = await prisma.pageOnTaxonomy.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many PageOnTaxonomies and only return the `pageId`
   * const pageOnTaxonomyWithPageIdOnly = await prisma.pageOnTaxonomy.createManyAndReturn({
   *   select: { pageId: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends PageOnTaxonomyCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, PageOnTaxonomyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PageOnTaxonomyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a PageOnTaxonomy.
   * @param {PageOnTaxonomyDeleteArgs} args - Arguments to delete one PageOnTaxonomy.
   * @example
   * // Delete one PageOnTaxonomy
   * const PageOnTaxonomy = await prisma.pageOnTaxonomy.delete({
   *   where: {
   *     // ... filter to delete one PageOnTaxonomy
   *   }
   * })
   * 
   */
  delete<T extends PageOnTaxonomyDeleteArgs>(args: Prisma.SelectSubset<T, PageOnTaxonomyDeleteArgs<ExtArgs>>): Prisma.Prisma__PageOnTaxonomyClient<runtime.Types.Result.GetResult<Prisma.$PageOnTaxonomyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one PageOnTaxonomy.
   * @param {PageOnTaxonomyUpdateArgs} args - Arguments to update one PageOnTaxonomy.
   * @example
   * // Update one PageOnTaxonomy
   * const pageOnTaxonomy = await prisma.pageOnTaxonomy.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends PageOnTaxonomyUpdateArgs>(args: Prisma.SelectSubset<T, PageOnTaxonomyUpdateArgs<ExtArgs>>): Prisma.Prisma__PageOnTaxonomyClient<runtime.Types.Result.GetResult<Prisma.$PageOnTaxonomyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more PageOnTaxonomies.
   * @param {PageOnTaxonomyDeleteManyArgs} args - Arguments to filter PageOnTaxonomies to delete.
   * @example
   * // Delete a few PageOnTaxonomies
   * const { count } = await prisma.pageOnTaxonomy.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends PageOnTaxonomyDeleteManyArgs>(args?: Prisma.SelectSubset<T, PageOnTaxonomyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more PageOnTaxonomies.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PageOnTaxonomyUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many PageOnTaxonomies
   * const pageOnTaxonomy = await prisma.pageOnTaxonomy.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends PageOnTaxonomyUpdateManyArgs>(args: Prisma.SelectSubset<T, PageOnTaxonomyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more PageOnTaxonomies and returns the data updated in the database.
   * @param {PageOnTaxonomyUpdateManyAndReturnArgs} args - Arguments to update many PageOnTaxonomies.
   * @example
   * // Update many PageOnTaxonomies
   * const pageOnTaxonomy = await prisma.pageOnTaxonomy.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more PageOnTaxonomies and only return the `pageId`
   * const pageOnTaxonomyWithPageIdOnly = await prisma.pageOnTaxonomy.updateManyAndReturn({
   *   select: { pageId: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends PageOnTaxonomyUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, PageOnTaxonomyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PageOnTaxonomyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one PageOnTaxonomy.
   * @param {PageOnTaxonomyUpsertArgs} args - Arguments to update or create a PageOnTaxonomy.
   * @example
   * // Update or create a PageOnTaxonomy
   * const pageOnTaxonomy = await prisma.pageOnTaxonomy.upsert({
   *   create: {
   *     // ... data to create a PageOnTaxonomy
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the PageOnTaxonomy we want to update
   *   }
   * })
   */
  upsert<T extends PageOnTaxonomyUpsertArgs>(args: Prisma.SelectSubset<T, PageOnTaxonomyUpsertArgs<ExtArgs>>): Prisma.Prisma__PageOnTaxonomyClient<runtime.Types.Result.GetResult<Prisma.$PageOnTaxonomyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of PageOnTaxonomies.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PageOnTaxonomyCountArgs} args - Arguments to filter PageOnTaxonomies to count.
   * @example
   * // Count the number of PageOnTaxonomies
   * const count = await prisma.pageOnTaxonomy.count({
   *   where: {
   *     // ... the filter for the PageOnTaxonomies we want to count
   *   }
   * })
  **/
  count<T extends PageOnTaxonomyCountArgs>(
    args?: Prisma.Subset<T, PageOnTaxonomyCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], PageOnTaxonomyCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a PageOnTaxonomy.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PageOnTaxonomyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends PageOnTaxonomyAggregateArgs>(args: Prisma.Subset<T, PageOnTaxonomyAggregateArgs>): Prisma.PrismaPromise<GetPageOnTaxonomyAggregateType<T>>

  /**
   * Group by PageOnTaxonomy.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PageOnTaxonomyGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends PageOnTaxonomyGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: PageOnTaxonomyGroupByArgs['orderBy'] }
      : { orderBy?: PageOnTaxonomyGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, PageOnTaxonomyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageOnTaxonomyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the PageOnTaxonomy model
 */
readonly fields: PageOnTaxonomyFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for PageOnTaxonomy.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__PageOnTaxonomyClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  page<T extends Prisma.PageDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PageDefaultArgs<ExtArgs>>): Prisma.Prisma__PageClient<runtime.Types.Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  taxonomy<T extends Prisma.TaxonomyDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TaxonomyDefaultArgs<ExtArgs>>): Prisma.Prisma__TaxonomyClient<runtime.Types.Result.GetResult<Prisma.$TaxonomyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the PageOnTaxonomy model
 */
export interface PageOnTaxonomyFieldRefs {
  readonly pageId: Prisma.FieldRef<"PageOnTaxonomy", 'String'>
  readonly taxonomyId: Prisma.FieldRef<"PageOnTaxonomy", 'String'>
}
    

// Custom InputTypes
/**
 * PageOnTaxonomy findUnique
 */
export type PageOnTaxonomyFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PageOnTaxonomy
   */
  select?: Prisma.PageOnTaxonomySelect<ExtArgs> | null
  /**
   * Omit specific fields from the PageOnTaxonomy
   */
  omit?: Prisma.PageOnTaxonomyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PageOnTaxonomyInclude<ExtArgs> | null
  /**
   * Filter, which PageOnTaxonomy to fetch.
   */
  where: Prisma.PageOnTaxonomyWhereUniqueInput
}

/**
 * PageOnTaxonomy findUniqueOrThrow
 */
export type PageOnTaxonomyFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PageOnTaxonomy
   */
  select?: Prisma.PageOnTaxonomySelect<ExtArgs> | null
  /**
   * Omit specific fields from the PageOnTaxonomy
   */
  omit?: Prisma.PageOnTaxonomyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PageOnTaxonomyInclude<ExtArgs> | null
  /**
   * Filter, which PageOnTaxonomy to fetch.
   */
  where: Prisma.PageOnTaxonomyWhereUniqueInput
}

/**
 * PageOnTaxonomy findFirst
 */
export type PageOnTaxonomyFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PageOnTaxonomy
   */
  select?: Prisma.PageOnTaxonomySelect<ExtArgs> | null
  /**
   * Omit specific fields from the PageOnTaxonomy
   */
  omit?: Prisma.PageOnTaxonomyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PageOnTaxonomyInclude<ExtArgs> | null
  /**
   * Filter, which PageOnTaxonomy to fetch.
   */
  where?: Prisma.PageOnTaxonomyWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PageOnTaxonomies to fetch.
   */
  orderBy?: Prisma.PageOnTaxonomyOrderByWithRelationInput | Prisma.PageOnTaxonomyOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for PageOnTaxonomies.
   */
  cursor?: Prisma.PageOnTaxonomyWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PageOnTaxonomies from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PageOnTaxonomies.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of PageOnTaxonomies.
   */
  distinct?: Prisma.PageOnTaxonomyScalarFieldEnum | Prisma.PageOnTaxonomyScalarFieldEnum[]
}

/**
 * PageOnTaxonomy findFirstOrThrow
 */
export type PageOnTaxonomyFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PageOnTaxonomy
   */
  select?: Prisma.PageOnTaxonomySelect<ExtArgs> | null
  /**
   * Omit specific fields from the PageOnTaxonomy
   */
  omit?: Prisma.PageOnTaxonomyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PageOnTaxonomyInclude<ExtArgs> | null
  /**
   * Filter, which PageOnTaxonomy to fetch.
   */
  where?: Prisma.PageOnTaxonomyWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PageOnTaxonomies to fetch.
   */
  orderBy?: Prisma.PageOnTaxonomyOrderByWithRelationInput | Prisma.PageOnTaxonomyOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for PageOnTaxonomies.
   */
  cursor?: Prisma.PageOnTaxonomyWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PageOnTaxonomies from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PageOnTaxonomies.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of PageOnTaxonomies.
   */
  distinct?: Prisma.PageOnTaxonomyScalarFieldEnum | Prisma.PageOnTaxonomyScalarFieldEnum[]
}

/**
 * PageOnTaxonomy findMany
 */
export type PageOnTaxonomyFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PageOnTaxonomy
   */
  select?: Prisma.PageOnTaxonomySelect<ExtArgs> | null
  /**
   * Omit specific fields from the PageOnTaxonomy
   */
  omit?: Prisma.PageOnTaxonomyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PageOnTaxonomyInclude<ExtArgs> | null
  /**
   * Filter, which PageOnTaxonomies to fetch.
   */
  where?: Prisma.PageOnTaxonomyWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PageOnTaxonomies to fetch.
   */
  orderBy?: Prisma.PageOnTaxonomyOrderByWithRelationInput | Prisma.PageOnTaxonomyOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing PageOnTaxonomies.
   */
  cursor?: Prisma.PageOnTaxonomyWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PageOnTaxonomies from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PageOnTaxonomies.
   */
  skip?: number
  distinct?: Prisma.PageOnTaxonomyScalarFieldEnum | Prisma.PageOnTaxonomyScalarFieldEnum[]
}

/**
 * PageOnTaxonomy create
 */
export type PageOnTaxonomyCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PageOnTaxonomy
   */
  select?: Prisma.PageOnTaxonomySelect<ExtArgs> | null
  /**
   * Omit specific fields from the PageOnTaxonomy
   */
  omit?: Prisma.PageOnTaxonomyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PageOnTaxonomyInclude<ExtArgs> | null
  /**
   * The data needed to create a PageOnTaxonomy.
   */
  data: Prisma.XOR<Prisma.PageOnTaxonomyCreateInput, Prisma.PageOnTaxonomyUncheckedCreateInput>
}

/**
 * PageOnTaxonomy createMany
 */
export type PageOnTaxonomyCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many PageOnTaxonomies.
   */
  data: Prisma.PageOnTaxonomyCreateManyInput | Prisma.PageOnTaxonomyCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * PageOnTaxonomy createManyAndReturn
 */
export type PageOnTaxonomyCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PageOnTaxonomy
   */
  select?: Prisma.PageOnTaxonomySelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the PageOnTaxonomy
   */
  omit?: Prisma.PageOnTaxonomyOmit<ExtArgs> | null
  /**
   * The data used to create many PageOnTaxonomies.
   */
  data: Prisma.PageOnTaxonomyCreateManyInput | Prisma.PageOnTaxonomyCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PageOnTaxonomyIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * PageOnTaxonomy update
 */
export type PageOnTaxonomyUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PageOnTaxonomy
   */
  select?: Prisma.PageOnTaxonomySelect<ExtArgs> | null
  /**
   * Omit specific fields from the PageOnTaxonomy
   */
  omit?: Prisma.PageOnTaxonomyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PageOnTaxonomyInclude<ExtArgs> | null
  /**
   * The data needed to update a PageOnTaxonomy.
   */
  data: Prisma.XOR<Prisma.PageOnTaxonomyUpdateInput, Prisma.PageOnTaxonomyUncheckedUpdateInput>
  /**
   * Choose, which PageOnTaxonomy to update.
   */
  where: Prisma.PageOnTaxonomyWhereUniqueInput
}

/**
 * PageOnTaxonomy updateMany
 */
export type PageOnTaxonomyUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update PageOnTaxonomies.
   */
  data: Prisma.XOR<Prisma.PageOnTaxonomyUpdateManyMutationInput, Prisma.PageOnTaxonomyUncheckedUpdateManyInput>
  /**
   * Filter which PageOnTaxonomies to update
   */
  where?: Prisma.PageOnTaxonomyWhereInput
  /**
   * Limit how many PageOnTaxonomies to update.
   */
  limit?: number
}

/**
 * PageOnTaxonomy updateManyAndReturn
 */
export type PageOnTaxonomyUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PageOnTaxonomy
   */
  select?: Prisma.PageOnTaxonomySelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the PageOnTaxonomy
   */
  omit?: Prisma.PageOnTaxonomyOmit<ExtArgs> | null
  /**
   * The data used to update PageOnTaxonomies.
   */
  data: Prisma.XOR<Prisma.PageOnTaxonomyUpdateManyMutationInput, Prisma.PageOnTaxonomyUncheckedUpdateManyInput>
  /**
   * Filter which PageOnTaxonomies to update
   */
  where?: Prisma.PageOnTaxonomyWhereInput
  /**
   * Limit how many PageOnTaxonomies to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PageOnTaxonomyIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * PageOnTaxonomy upsert
 */
export type PageOnTaxonomyUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PageOnTaxonomy
   */
  select?: Prisma.PageOnTaxonomySelect<ExtArgs> | null
  /**
   * Omit specific fields from the PageOnTaxonomy
   */
  omit?: Prisma.PageOnTaxonomyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PageOnTaxonomyInclude<ExtArgs> | null
  /**
   * The filter to search for the PageOnTaxonomy to update in case it exists.
   */
  where: Prisma.PageOnTaxonomyWhereUniqueInput
  /**
   * In case the PageOnTaxonomy found by the `where` argument doesn't exist, create a new PageOnTaxonomy with this data.
   */
  create: Prisma.XOR<Prisma.PageOnTaxonomyCreateInput, Prisma.PageOnTaxonomyUncheckedCreateInput>
  /**
   * In case the PageOnTaxonomy was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.PageOnTaxonomyUpdateInput, Prisma.PageOnTaxonomyUncheckedUpdateInput>
}

/**
 * PageOnTaxonomy delete
 */
export type PageOnTaxonomyDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PageOnTaxonomy
   */
  select?: Prisma.PageOnTaxonomySelect<ExtArgs> | null
  /**
   * Omit specific fields from the PageOnTaxonomy
   */
  omit?: Prisma.PageOnTaxonomyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PageOnTaxonomyInclude<ExtArgs> | null
  /**
   * Filter which PageOnTaxonomy to delete.
   */
  where: Prisma.PageOnTaxonomyWhereUniqueInput
}

/**
 * PageOnTaxonomy deleteMany
 */
export type PageOnTaxonomyDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which PageOnTaxonomies to delete
   */
  where?: Prisma.PageOnTaxonomyWhereInput
  /**
   * Limit how many PageOnTaxonomies to delete.
   */
  limit?: number
}

/**
 * PageOnTaxonomy without action
 */
export type PageOnTaxonomyDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PageOnTaxonomy
   */
  select?: Prisma.PageOnTaxonomySelect<ExtArgs> | null
  /**
   * Omit specific fields from the PageOnTaxonomy
   */
  omit?: Prisma.PageOnTaxonomyOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PageOnTaxonomyInclude<ExtArgs> | null
}
